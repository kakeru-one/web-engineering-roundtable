# SQLの苦手を克服する本の学習メモ
## IN句とEXISTS句の使い分け
### 前提条件
以下のテーブルがあるとする。
- songsテーブル(主表)
  - 曲名
  - 発表年
  - 販売数
  - id
- attrテーブル(従属表)
  - s_id
    - songsとの外部キー
  - 季節
  - テーマ

#### 選択性についての前提条件

| 条件 | 主表/従属表 | 選択性 | 比率 |
| ---- | ---- | ---- | ---- |
| 発表年 > 1990 | 主表 | 低い | 50% |
| 販売数 > 300000 | 主表 | 高い | 1%以下 |
| テーマ <> 失恋 | 従属表 | 低い | 80% |

#### EXISTS句を使用する場合
```sql
SELECT * FROM songs s
WHERE s.発表年 > 1990
  AND s.販売数 > 300000
  AND EXISTS (
    SELECT 1 FROM atrr a
    WHERE
      s.id = a.s_id
      AND テーマ <> "失恋"
  );
```
#### IN句を使用する場合
```sql
SELECT * FROm songs s
WHERE id IN (
    SELECT s_id FROM attr
    WHERE テーマ <> "失恋"
  )
  AND s.発表年 > 1990
  AND s.販売数 > 300000;
```

- IN句とExists句は実行タイミングが違う。
  - 主表と従属表があるとして、従属表側のフィルタで、それぞれの句を実行するとする。
  - IN句は引数となるサブクエリ内の処理が先に実行されて、その結果に基づいて主表が絞り込まれた上で、主表にたいするWhereが実行される。
  - Exists句内のサブクエリは、主表のWhere句が実行されたあとに、実行される。
- したがって、主表と従属表の絞り込みの度合いによって、使い分ける必要がある。

## indexについて
### 前提
- 以下の構成を考える。
  - CPU -> キャッシュメモリ -> HDD
  - キャッシュメモリには、HDDのデータを読み込むと一旦メモリに載るけど、メモリの容量を超えると、捨てられてしまう。
    - キャッシュメモリに載っていないデータはHDDに検索しにいく。
### なぜ速くなるのか
- B+Treeインデックスを用いると、HDDのページをピンポイントで読み出せるようにする。

### indexが役に立たない時（フルスキャンの方が早い時は？）
- HDDのページ数が、`B+Treeの階層` + `条件にヒットした実データ` の数以下の場合は、フルスキャンの方が速い。
  - 条件にヒットしたデータが多すぎると、読み込むページ数が増えるため、フルスキャンとほぼ変わらん。
  - つまり、言い換えると **「検索結果が少ないほど、indexによる効果が大きくなる」** と言える
- 部分一致検索では、前方一致検索ではindexが効くけど、検索結果が非常に多いと、データテーブルのページに大量ヒットするため、インデックスの効果が薄れる。
  - e.g. 読み仮名カラムに対して、`サ%`のような条件で検索した場合には、検索結果が非常に多くなる。

### 発展的な内容
SQLパフォーマンス詳解を読んで、以下の内容を理解した方が良さそう。
- 削除フラグに有効なindexを貼る方法
- 文字数の多いテキスト型のカラムにインデックスを貼る方法
- ngram
  - https://tech.bita.jp/article/4

## JOINについて
### 3つのアルゴリズム
- ネステッドループ結合
  - 外部表の各行に対して、内部表の各行を照らし合わせて、結合判定を行うイメージ。
    - なので、結合条件を適応した結果が外部表10000件かつ内部表10000件だと、10000 × 10000 = 1億レコード分走査する必要が出てくる。
    - 内部表にインデックスが貼られていると、10000件 × （カーティナリティによるけど、かなり小さい数） になるので、かなり高速化される。
      - 比較回数は内部表のカーディナリティ（重複なく値がどれだけ存在するか）に依存する。
  - MySQLではネステッドループ結合がメインのアルゴリズムになってそう。（以下はアルゴリズム）
    - https://dev.mysql.com/doc/refman/8.0/ja/nested-loop-joins.html
    - https://github.com/mysql/mysql-server/blob/trunk/sql/nested_join.h
- ソート/マージ結合
  - 比較対象の列の値で両テーブルの行をソート（並べ替え）し、先頭から順に結合する方式。外部表と内部表の二次元表があるとして、対角線上のものだけを走査するイメージ。
    - https://e-words.jp/w/%E3%82%BD%E3%83%BC%E3%83%88%E3%83%9E%E3%83%BC%E3%82%B8%E7%B5%90%E5%90%88.html
    - ソートする負荷がかかるため、外部表と内部表の結合条件のカラムにはインデックスが貼られていることが前提となる。
- ハッシュ結合
  - 内部表の結合条件列の値をハッシュ関数にかけてメモリ上にハッシュテーブルを作った上で、外部表の値を同じハッシュ関数にかけてマッチングの候補となる内部表の値を探す。
    - 等価結合の場合のみ使用可能。
      - これは、ハッシュ値では、カラムの値の大小比較ができないため。
    - 計算量の観点では、ネステッドループ結合とは異なり、足し算になる。
    - 以下の記事でのアルゴリズムの説明がわかりやすい。
      - https://zenn.dev/captain_blue/articles/three-types-of-join-algorithms#hash-join
      - SQLのハッシュ結合で使用されるハッシュテーブルでは、ハッシュ値の衝突（collision）を許容し、同じハッシュバケット（bucket）に複数の値を格納する。
  - どんな時に使えるかで言うと、結合条件のカラムにindexを貼っていない場合に使える。
  - MySQL、ハッシュ結合も提供してるっぽい。
    - https://dev.mysql.com/doc/refman/8.0/ja/hash-joins.html
    - https://github.com/mysql/mysql-server/blob/824e2b4064053f7daf17d7f3f84b7a3ed92e5fb4/sql/iterators/hash_join_iterator.h

### 前提知識の部分
- ハッシュテーブルとは？  
  - キーと値の組（エントリと呼ぶ）を複数個格納し、キーに対応する値をすばやく参照するためのデータ構造のこと。
  - rubyのHashをイメージするとわかりやすいと思う。
  - https://ja.wikipedia.org/wiki/%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB
  - https://wa3.i-3-i.info/word11947.html
- ハッシュ関数とは？
  - 任意のデータから、別の（多くの場合は短い固定長の）値を得るための操作、または、その様な値を得るための関数のこと。
    - https://ja.wikipedia.org/wiki/%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E9%96%A2%E6%95%B0
    - https://wa3.i-3-i.info/word11948.html

## デッドロックについて
### デッドロックの回避方法
- APIファースト開発
  - 負荷の高いサービスだと、DB側にもAPIを作成し、APP側からは必ずそのAPIを通してDBを使用するようにする。

## APサーバーで集計するよりも、DBサーバーで集計した方が高速になる
### 比較した時のSQLとコード
#### 集計型SQL
DB側で集計までやってしまう例。
この場合だと、DBからAPPに集計した値を三つ返すだけで良くなる。
```sql
SELECT SUM(billing), MAX(billing), AVG(billing)
FROM orders
WHERE order_date = '2017/3/1';
```

以下のような処理順序になる。

1. HDDからメモリへデータを読み出す。
2. HDDから読み出したままの生データを扱いやすいようにテーブル形式に整形する。(HDDにはレコードのデータはテーブル形式で保存されているわけではない。)
3. CPU内で、SUM, MAX, AVGの集計関数で集計する。
4. 3.で集計した三つのデータのみをDBサーバからAPPサーバに転送する。

#### 非集計型SQL
APP側で合計・最大値・平均値を算出する例。
この場合だと、DBから、APPにbillingカラムの値を全て渡す必要が出てくる。
```sql
SELECT billing
FROM orders
WHERE order_date = '2017/3/1';
```

以下のような処理順序になる。

1. HDDからメモリへデータを読み出す。
2. HDDから読み出したままの生データを扱いやすいようにテーブル形式に整形する。(HDDにはレコードのデータはテーブル形式で保存されているわけではない。)
3. メモリ上のテーブル形式のデータから、billingカラムのデータのみを取り出す。
4. 3.のデータをDBサーバからAPPサーバに転送する。

### なぜDB側で集計した方がDB側でも低負荷になるのか？
- DBからAPPへのデータ転送量がかなり減るので、比較すると集計型SQLの方が、データの転送時間がかなり短くなるため。
- 【集計型SQL】DBサーバーでの集計関数の処理の負荷 < 【非集計型SQL】billingカラムの切り出し処理
  - SQLでの集計関数の処理は、DBサーバーのCPU内で行われるので、とても高速なため。
  - 集計型SQLでは、メモリ内でのbillingカラムの切り出し処理が不要になるため。  

### 前提知識
- 帯域幅について
  - 単位はビット毎秒。
- I/Fとは？
  - 「インターフェース」の省略表現のこと。
  - https://wa3.i-3-i.info/word110409.html
- オーバーヘッドとは？
  - 処理や通信に際して間接的に生じる負荷などを指す。
  - https://wa3.i-3-i.info/word12471.html
  - https://e-words.jp/w/%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%98%E3%83%83%E3%83%89.html

## DBがボトルネックになる場合
### DBサーバー内で使われるメモリについて
#### バッファプール
- HDD読み出しに関わる部分。
- 主な役割はテーブルのデータをキャッシュしてHDD読み出し回数を減らすこと。
  - MySQLでの用語なので、他のRDBMSでは名称が異なるかも。
- ちなみに、先ほどの節でのメモリは、このバッファプールのことを指している。

#### ライブラリバッファ/SQLキャッシュ
- パース・オプティマイズに関わる部分。

#### ワークスペース
- DB側で、SQLのソート・JOIN・集計関数などのデータ加工で使われるメモリ。

### JOINさせるとスケールアウトしづらい？
- DBサーバーをスケールアウトする場合を考える。
- ECサイトのアプリケーションかつ、注文履歴という概念があるとする。
  - 閲覧する際は以下のテーブルをJOINする。
    - 売上明細テーブル（トランザクションデータ）
    - 商品マスタテーブル（マスターデータ）
  - 上記のケースで、DBサーバーを以下のようにスケールアウトさせるとすると、JOINする際にサーバーを跨いだ処理になってしまってボトルネックになってしまう。
    - 「マスターデータ用サーバ」
      - 商品マスタテーブル（マスターデータ）
    - 「トランザクションデータ用サーバA」
      - 売上明細テーブル（トランザクションデータ）の前半データ
    - 「トランザクションデータ用サーバB」
      - 売上明細テーブル（トランザクションデータ）の後半データ
  - そこで、以下のような方法を取る。
    - トランザクションデータ用サーバそれぞれに、商品マスタテーブルのデータを全てコピーしておくようにする。
      - これにより、参照系の操作はトランザクションデータ用サーバ内で完結する
    - マスタ系データの更新は、マスタデータ用のサーバーに対してのみ行い、各トランザクション用サーバに自動的に反映させるようにする。
      - これを実現する手段としては、以下がある。
        - DBリンクを使ったマテリアライズドビュー
        - トリガーでコピーする
        - DBリンクがないMySQLの場合は、レプリケーションする

### 前提知識
- スケールアップ
  - サーバーの性能を上げる方法
- スケールアウト
  - サーバーの数を増やす方法っb0
